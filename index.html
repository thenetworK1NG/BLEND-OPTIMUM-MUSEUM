<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js - misc - octree collisions (My Art)</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
  <link type="text/css" rel="stylesheet" href="https://threejs.org/examples/main.css" />
  <style>
    html, body { height: 100%; overscroll-behavior: contain; }
    body { margin: 0; user-select: none; -webkit-user-select: none; touch-action: none; }
    #joystick {
      position: fixed; left: 20px; bottom: 20px; width: 120px; height: 120px;
      border-radius: 50%; background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.15); display: none; z-index: 9;
      box-sizing: border-box; touch-action: none;
    }
    #joystickKnob {
      position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%);
      width: 56px; height: 56px; border-radius: 50%;
      background: rgba(255,255,255,0.28); border: 1px solid rgba(255,255,255,0.35);
      box-shadow: 0 0 8px rgba(0,0,0,0.2);
      pointer-events: none;
    }
    #mobileOverlay { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 10; background: rgba(0,0,0,0.6); color: #fff; }
    #mobileOverlay.show { display: flex; }
    #mobileOverlay .panel { text-align: center; background: rgba(0,0,0,0.5); padding: 16px 24px; border-radius: 10px; }
    #mobileOverlay button { margin-top: 10px; padding: 10px 16px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.35); background: rgba(255,255,255,0.15); color: #fff; }
  /* Simple mobile loader: full-screen black with centered loading bar */
  .mobile-loader-wrapper { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; z-index: 2147483649; background: #000; }
  .mobile-loader { width: 80%; max-width: 380px; text-align: center; color: #fff; }
  .mobile-loader-text { font-family: Inter, sans-serif; font-size: 16px; margin-bottom: 12px; opacity: 0.95; }
  .mobile-loader-bar { width: 100%; height: 12px; background: rgba(255,255,255,0.08); border-radius: 8px; overflow: hidden; }
  .mobile-loader-fill { width: 0%; height: 100%; background: linear-gradient(90deg, #0af, #7df); transition: width 160ms linear; }
  .mobile-loader-subtext { font-family: Inter, sans-serif; font-size: 12px; margin-top: 8px; opacity: 0.8; }
  </style>
  </head>
  <body>
    
  <div id="container"></div>
    <div id="joystick"><div id="joystickKnob"></div></div>
    <div id="mobileOverlay">
      <div class="panel">
        <div style="font-weight:600; margin-bottom:6px;">Rotate device to landscape</div>
        <div>Tap to play; drag to look, left joystick to move.</div>
        <button id="startBtn">Start</button>
      </div>
    </div>

    <!-- Simple mobile loader: full-screen black with centered loading bar -->
    <div class="mobile-loader-wrapper" id="mobileLoader" role="status" aria-live="polite">
      <div class="mobile-loader">
        <div class="mobile-loader-text" id="mobileLoaderText">Loading scene... 0%</div>
        <div class="mobile-loader-bar" aria-hidden="true">
          <div class="mobile-loader-fill" id="mobileLoaderFill"></div>
        </div>
        <div class="mobile-loader-subtext" id="mobileLoaderSub">Please wait while the scene downloads.</div>
      </div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.180.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.180.0/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';
      import Stats from 'three/addons/libs/stats.module.js';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import { Octree } from 'three/addons/math/Octree.js';
      import { OctreeHelper } from 'three/addons/helpers/OctreeHelper.js';
      import { Capsule } from 'three/addons/math/Capsule.js';
      import { GUI } from 'three/addons/libs/lil-gui.module.min.js';
  import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';

  const clock = new THREE.Clock();

  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x88ccee);
  // Fog disabled by default
  scene.fog = null;

  // Mobile detection and mode
  const isMobile = /Android|iPhone|iPad|iPod|Opera Mini|IEMobile/i.test(navigator.userAgent);

  // Camera setup
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.rotation.order = 'YXZ';

      // On mobile we simplify lighting to save GPU work: single ambient light and no shadows / env maps
      let fillLight1, ambientLight, directionalLight;
      if (isMobile) {
  ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);
  // Hemisphere light: default settings (from user-specified values)
  fillLight1 = new THREE.HemisphereLight(0xfffdf5, 0xffffff, 3.07);
  fillLight1.position.set(2, 1, 1);
  scene.add(fillLight1);
        // Directional light intentionally disabled on mobile (intensity 0)
        directionalLight = new THREE.DirectionalLight(0xffffff, 0);
        directionalLight.castShadow = false;
        // not added to scene
      } else {
  // Hemisphere light: default settings (from user-specified values)
  fillLight1 = new THREE.HemisphereLight(0xfffdf5, 0xffffff, 3.07);
  fillLight1.position.set(2, 1, 1);
  scene.add(fillLight1);

        // Subtle ambient to avoid fully black shadows on non-PBR materials
  ambientLight = new THREE.AmbientLight(0xffffff, 1);
        scene.add(ambientLight);

        // Directional light intentionally disabled (intensity 0)
        directionalLight = new THREE.DirectionalLight(0xffffff, 0);
        directionalLight.position.set(-5, 25, -1);
        directionalLight.castShadow = false;
        // shadow settings omitted because directional light is disabled
        // not added to scene
      }

      const container = document.getElementById('container');

  // Renderer: reduce quality on mobile to improve performance
  const renderer = new THREE.WebGLRenderer({ antialias: !isMobile });
  const maxPixelRatio = isMobile ? Math.min(1.5, window.devicePixelRatio) : window.devicePixelRatio;
  renderer.setPixelRatio(maxPixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setAnimationLoop(animate);
  renderer.shadowMap.enabled = !isMobile; // disable shadows on mobile
      renderer.shadowMap.type = THREE.VSMShadowMap;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      container.appendChild(renderer.domElement);

  // Prefiltered environment map (IBL) for realistic ambient lighting - skip on mobile for perf
  let roomEnvMap = null;
  if (!isMobile) {
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    const roomEnvScene = new RoomEnvironment(renderer);
    const envRT = pmremGenerator.fromScene(roomEnvScene);
    roomEnvMap = envRT.texture;
  }

  const stats = new Stats();
  stats.domElement.style.position = 'absolute';
  stats.domElement.style.top = '0px';
  // Hide the FPS stats on mobile to reduce DOM overhead
  stats.domElement.style.display = isMobile ? 'none' : 'block';
  container.appendChild(stats.domElement);

  // Custom average FPS display (shows >60Hz and a running average)
  const fpsDisplay = document.createElement('div');
  fpsDisplay.id = 'fpsDisplay';
  Object.assign(fpsDisplay.style, {
    position: 'absolute',
    top: '0px',
    right: '0px',
    padding: '6px 8px',
    color: '#0ff',
    background: 'rgba(0,0,0,0.45)',
    fontFamily: 'monospace',
    fontSize: '12px',
    borderRadius: '0 0 6px 0',
    pointerEvents: 'none',
    zIndex: 1000,
  });
  fpsDisplay.style.display = isMobile ? 'none' : 'block';
  // Compose display with prominent average and smaller instantaneous
  const avgSpan = document.createElement('div');
  avgSpan.id = 'fpsAvg';
  Object.assign(avgSpan.style, {
    fontSize: '14px',
    fontWeight: '700',
    color: '#0ff',
    lineHeight: '1',
  });
  avgSpan.textContent = 'AVG: --.- FPS';

  const instSpan = document.createElement('div');
  instSpan.id = 'fpsInst';
  Object.assign(instSpan.style, {
    fontSize: '11px',
    color: '#9ff',
    opacity: '0.9',
    lineHeight: '1',
  });
  instSpan.textContent = 'INST: --.-';

  fpsDisplay.appendChild(avgSpan);
  fpsDisplay.appendChild(instSpan);
  container.appendChild(fpsDisplay);

  // Simple moving-average buffer for FPS (keeps last N samples)
  const FPS_SAMPLE_MAX = 120; // ~2 seconds at 60Hz
  const fpsSamples = [];

      const GRAVITY = 30;

      const STEPS_PER_FRAME = isMobile ? 2 : 5;
  const worldOctree = new Octree();

      const playerCollider = new Capsule(new THREE.Vector3(0, 0.35, 0), new THREE.Vector3(0, 1, 0), 0.35);

      const playerVelocity = new THREE.Vector3();
      const playerDirection = new THREE.Vector3();

      let playerOnFloor = false;
  // Mobile walk/run mode flag and factor (walking is default)
  let isMobileWalking = true;
  const MOBILE_WALK_FACTOR = 0.5; // walk is 50% of standard speed
  // mouseTime removed - throwing balls disabled

      const keyStates = {};

      const vector1 = new THREE.Vector3();
      const vector2 = new THREE.Vector3();
      const vector3 = new THREE.Vector3();

      document.addEventListener('keydown', (event) => {
        keyStates[event.code] = true;
      });

      document.addEventListener('keyup', (event) => {
        keyStates[event.code] = false;
      });

      container.addEventListener('mousedown', () => {
        document.body.requestPointerLock();
      });


      function clampPitch() {
        const halfPi = Math.PI / 2 - 0.01;
        camera.rotation.x = Math.max(-halfPi, Math.min(halfPi, camera.rotation.x));
      }
      document.body.addEventListener('mousemove', (event) => {
        if (document.pointerLockElement === document.body) {
          camera.rotation.y -= event.movementX / 500;
          camera.rotation.x -= event.movementY / 500;
          clampPitch();
        }
      });

  // --- Mobile support: orientation, touch look, and joystick move ---
      const overlay = document.getElementById('mobileOverlay');
      const startBtn = document.getElementById('startBtn');
  const joystick = document.getElementById('joystick');
  const knob = document.getElementById('joystickKnob');
  // Track a specific touch id for touch-look so joystick touches don't conflict
  let touchLookActive = false;
  let touchLookId = null;
  let lastTouchX = 0, lastTouchY = 0;
  let joyActive = false;
  let joyCx = 0, joyCy = 0, joyR = 0;
  let joyTouchId = null;
      const joyVec = new THREE.Vector2(0, 0); // x=left/right, y=forward/back

      function isLandscape() {
        return (window.innerWidth >= window.innerHeight);
      }

      function updateOverlay() {
        if (isMobile && !isLandscape()) overlay.classList.add('show');
        else overlay.classList.remove('show');
      }
      window.addEventListener('orientationchange', () => setTimeout(updateOverlay, 50));
      window.addEventListener('resize', () => setTimeout(updateOverlay, 50));
      updateOverlay();

      // Start button allows entering play without pointer lock on mobile
      startBtn?.addEventListener('click', () => {
        overlay.classList.remove('show');
        // On desktop, optionally enter pointer lock
        if (!isMobile) document.body.requestPointerLock?.();
      });

      // Touch to look (drag anywhere on right 65% of screen)
      function onTouchStart(e) {
        if (!isMobile) return;
        for (const t of e.changedTouches) {
          const x = t.clientX, y = t.clientY;
          // Right 65% of screen is for looking
          if (x > window.innerWidth * 0.35 && touchLookId === null) {
            touchLookActive = true;
            touchLookId = t.identifier;
            lastTouchX = x; lastTouchY = y;
            break; // only take the first valid look touch
          }
        }
      }
      function onTouchMove(e) {
        if (!isMobile) return;
        if (!touchLookActive || touchLookId === null) return;
        // Find the changed touch that matches the touchLookId
        let t = null;
        for (let i = 0; i < e.changedTouches.length; i++) {
          if (e.changedTouches[i].identifier === touchLookId) { t = e.changedTouches[i]; break; }
        }
        if (!t) return;
        const dx = t.clientX - lastTouchX; const dy = t.clientY - lastTouchY;
        camera.rotation.y -= dx / 250; // more sensitive on mobile
        camera.rotation.x -= dy / 250;
        clampPitch();
        lastTouchX = t.clientX; lastTouchY = t.clientY;
      }
      function onTouchEnd(e) {
        if (!isMobile) return;
        if (!touchLookActive || touchLookId === null) return;
        if (e && e.changedTouches) {
          for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === touchLookId) {
              touchLookActive = false; touchLookId = null; break;
            }
          }
        } else {
          touchLookActive = false; touchLookId = null;
        }
      }
      window.addEventListener('touchstart', onTouchStart, { passive: false });
      window.addEventListener('touchmove', onTouchMove, { passive: false });
      window.addEventListener('touchend', onTouchEnd, { passive: false });

      // Virtual joystick (left bottom)
      function initJoystick() {
        if (!isMobile) return;
        joystick.style.display = 'block';
        function computeRect() {
          const rect = joystick.getBoundingClientRect();
          joyCx = rect.left + rect.width / 2; joyCy = rect.top + rect.height / 2; joyR = rect.width * 0.5 - 4;
          return rect;
        }
        let rect = computeRect();
        function setKnob(x, y) {
          knob.style.left = x + 'px'; knob.style.top = y + 'px';
        }
        setKnob(rect.width / 2, rect.height / 2);

        joystick.addEventListener('touchstart', (e) => {
          e.preventDefault(); joyActive = true;
          rect = computeRect();
          const t = e.changedTouches[0];
          joyTouchId = t.identifier;
        }, { passive: false });
        joystick.addEventListener('touchmove', (e) => {
          e.preventDefault();
          let t = null;
          for (let i = 0; i < e.changedTouches.length; i++) {
            if (e.changedTouches[i].identifier === joyTouchId) { t = e.changedTouches[i]; break; }
          }
          if (!t) return;
          const dx = t.clientX - joyCx; const dy = t.clientY - joyCy;
          const v = new THREE.Vector2(dx, dy);
          if (v.length() > joyR) v.setLength(joyR);
          setKnob(v.x + rect.width / 2, v.y + rect.height / 2);
          joyVec.set(v.x / joyR, v.y / joyR);
        }, { passive: false });
        const reset = (e) => {
          if (e) {
            let ended = false;
            for (let i = 0; i < e.changedTouches.length; i++) {
              if (e.changedTouches[i].identifier === joyTouchId) { ended = true; break; }
            }
            if (!ended) return;
          }
          joyActive = false; joyVec.set(0,0); setKnob(rect.width/2, rect.height/2); joyTouchId = null;
        };
        joystick.addEventListener('touchend', reset);
        joystick.addEventListener('touchcancel', reset);

        // Recompute center on rotate/resize to keep the knob centered
        const recalc = () => { rect = computeRect(); setKnob(rect.width/2, rect.height/2); };
        window.addEventListener('orientationchange', () => setTimeout(recalc, 100));
        window.addEventListener('resize', () => setTimeout(recalc, 100));
      }
      initJoystick();

      // Mobile: add Walk / Run buttons near joystick
      if (isMobile) {
        const walkBtn = document.createElement('button');
        walkBtn.id = 'walkBtn';
        walkBtn.type = 'button';
        walkBtn.title = 'Walk';
        // inline white SVG icon (pedestrian)
        walkBtn.innerHTML = '<svg width="32" height="32" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><g fill="#fff"><circle cx="12" cy="4" r="2"/><path d="M10.5 8.5c-.3 0-.6.1-.8.3L8 10.5 9 12l1.5-1 .5 3H12l-.6-3.4L10.8 9.2c.2-.1.3-.2.3-.7 0-.4-.2-.5-.6-.5zM7 16v2h2v-2H7zm5-1l1.5 2H16v-2h-4z"/></g></svg>';
        Object.assign(walkBtn.style, {
          position: 'fixed',
          right: '20px',
          bottom: '60px',
          zIndex: 2147483646,
          width: '56px',
          height: '56px',
          borderRadius: '12px',
          border: '1px solid rgba(255,255,255,0.12)',
          background: 'rgba(0,0,0,0.45)',
          padding: '0',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          cursor: 'pointer',
          backdropFilter: 'blur(4px)'
        });
        document.body.appendChild(walkBtn);

        const runBtn = document.createElement('button');
        runBtn.id = 'runBtn';
        runBtn.type = 'button';
        runBtn.title = 'Run';
        // inline white SVG icon (running)
        runBtn.innerHTML = '<svg width="32" height="32" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true"><g fill="#fff"><circle cx="7" cy="4" r="1.6"/><path d="M12 8l-1 3 2 1 1-2 2 1-1 4h2l1-5-3-2-1 1-1-4zM5 18h2v-2H5v2z"/></g></svg>';
        Object.assign(runBtn.style, {
          position: 'fixed',
          right: '20px',
          bottom: '120px',
          zIndex: 2147483646,
          width: '56px',
          height: '56px',
          borderRadius: '12px',
          border: '1px solid rgba(255,255,255,0.12)',
          background: 'rgba(0,0,0,0.45)',
          padding: '0',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          cursor: 'pointer',
          backdropFilter: 'blur(4px)'
        });
        document.body.appendChild(runBtn);

        // default: walking is the default mode on mobile
        isMobileWalking = true;
        runBtn.style.opacity = '0.7';
        runBtn.style.zIndex = 2147483647;
        walkBtn.style.opacity = '1.0';

        // small toast to notify user of current mode
        const modeToast = document.createElement('div');
        modeToast.id = 'modeToast';
        Object.assign(modeToast.style, {
          position: 'fixed',
          right: '50%',
          bottom: '35%',
          transform: 'translateX(50%)',
          padding: '10px 16px',
          borderRadius: '10px',
          background: 'rgba(0,0,0,0.65)',
          color: '#fff',
          fontWeight: '600',
          zIndex: 2147483648,
          display: 'none',
          pointerEvents: 'none'
        });
        document.body.appendChild(modeToast);

        function showModeToast(text) {
          modeToast.textContent = text;
          modeToast.style.display = '';
          modeToast.style.opacity = '1';
          setTimeout(() => {
            modeToast.style.transition = 'opacity 500ms ease';
            modeToast.style.opacity = '0';
            setTimeout(() => { modeToast.style.display = 'none'; modeToast.style.transition = ''; }, 600);
          }, 900);
        }

        showModeToast('WALKING');

        walkBtn.addEventListener('click', () => {
          isMobileWalking = true;
          walkBtn.style.opacity = '1.0';
          runBtn.style.opacity = '0.7';
          showModeToast('WALKING');
        });
        runBtn.addEventListener('click', () => {
          isMobileWalking = false;
          runBtn.style.opacity = '1.0';
          walkBtn.style.opacity = '0.7';
          showModeToast('RUNNING');
        });
      }

      window.addEventListener('resize', onWindowResize);

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // throwBall removed - no ball/projectile functionality

      function playerCollisions() {
        const result = worldOctree.capsuleIntersect(playerCollider);
        playerOnFloor = false;
        if (result) {
          playerOnFloor = result.normal.y > 0;
          if (!playerOnFloor) {
            playerVelocity.addScaledVector(result.normal, -result.normal.dot(playerVelocity));
          }
          if (result.depth >= 1e-10) {
            playerCollider.translate(result.normal.multiplyScalar(result.depth));
          }
        }
      }

      function updatePlayer(deltaTime) {
        let damping = Math.exp(-4 * deltaTime) - 1;
        if (!playerOnFloor) {
          playerVelocity.y -= GRAVITY * deltaTime;
          damping *= 0.1;
        }
        playerVelocity.addScaledVector(playerVelocity, damping);
        const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
        playerCollider.translate(deltaPosition);
        playerCollisions();
        camera.position.copy(playerCollider.end);
      }

      // sphere/ball physics removed

      function getForwardVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        return playerDirection;
      }

      function getSideVector() {
        camera.getWorldDirection(playerDirection);
        playerDirection.y = 0;
        playerDirection.normalize();
        playerDirection.cross(camera.up);
        return playerDirection;
      }

  // Mobile walk/run mode: run = standard speed, walk = slower (variables declared earlier)

      function controls(deltaTime) {
        let baseSpeed = playerOnFloor ? 25 : 8;
        if (isMobile && isMobileWalking) baseSpeed *= MOBILE_WALK_FACTOR;
        const speedDelta = deltaTime * baseSpeed;
        // Keyboard (desktop)
        if (keyStates['KeyW']) playerVelocity.add(getForwardVector().multiplyScalar(speedDelta));
        if (keyStates['KeyS']) playerVelocity.add(getForwardVector().multiplyScalar(-speedDelta));
        if (keyStates['KeyA']) playerVelocity.add(getSideVector().multiplyScalar(-speedDelta));
        if (keyStates['KeyD']) playerVelocity.add(getSideVector().multiplyScalar(speedDelta));
        // Jumping removed - Space no longer gives upward velocity
        // Joystick (mobile)
        if (joyVec.lengthSq() > 0.0001) {
          const forward = getForwardVector().clone();
          const side = getSideVector().clone();
          // joyVec.y: up is negative (screen coords), invert
          playerVelocity.add(forward.multiplyScalar(-joyVec.y * speedDelta));
          playerVelocity.add(side.multiplyScalar(joyVec.x * speedDelta));
        }
  }

  // Load local map file (use a cache-busting query param so updated models are fetched by clients)
  const loader = new GLTFLoader();
  // If you host updated models frequently, adding a version or timestamp query string
  // forces the browser to request the latest file instead of using a cached copy.
  const modelUrl = 'map.glb' + (location.search.includes('modelver=') ? '' : '?v=' + Date.now());

  // Mobile loader element and helpers
  const mobileLoaderEl = document.getElementById('mobileLoader');
  const mobileLoaderText = document.getElementById('mobileLoaderText');
  const mobileLoaderFill = document.getElementById('mobileLoaderFill');
  const mobileLoaderSub = document.getElementById('mobileLoaderSub');
  function showMobileLoader() { if (mobileLoaderEl) mobileLoaderEl.style.display = 'flex'; }
  function hideMobileLoader() { if (mobileLoaderEl) mobileLoaderEl.style.display = 'none'; }

  // Only show the loader on mobile devices
  if (isMobile) showMobileLoader();

  // GLTFLoader progress callback (some servers may not provide total length)
  function onProgress(xhr) {
    if (!mobileLoaderText || !mobileLoaderFill) return;
    if (xhr.lengthComputable) {
      const percent = Math.min(100, Math.round((xhr.loaded / xhr.total) * 100));
      mobileLoaderText.textContent = `Loading scene... ${percent}%`;
      mobileLoaderFill.style.width = percent + '%';
      mobileLoaderSub.textContent = 'Downloading assets...';
    } else {
      const kb = Math.round(xhr.loaded / 1024);
      mobileLoaderText.textContent = `Loading scene... ${kb} KB`;
      // show an indeterminate-like progress (grow slightly)
      const approx = Math.min(95, 10 + Math.floor(kb / 50));
      mobileLoaderFill.style.width = approx + '%';
      mobileLoaderSub.textContent = 'Downloading assets...';
    }
  }

  function onError(err) {
    if (mobileLoaderText) mobileLoaderText.textContent = 'Failed to load scene. Try reloading.';
    if (mobileLoaderSub) mobileLoaderSub.textContent = '';
    console.error('Error loading model:', err);
    // keep the error visible a short while, then hide
    setTimeout(hideMobileLoader, 4000);
  }

  loader.load(modelUrl, (gltf) => {
        // Model loaded successfully; hide the mobile loader
        hideMobileLoader();
        scene.add(gltf.scene);
        gltf.scene.updateMatrixWorld(true);
        worldOctree.fromGraphNode(gltf.scene);
        gltf.scene.traverse((child) => {
          if (child.isMesh) {
            child.castShadow = true;
            child.receiveShadow = true;
            if (child.material.map) {
              child.material.map.anisotropy = 4;
            }
          }
        });
        const helper = new OctreeHelper(worldOctree);
        helper.visible = false;
        scene.add(helper);
        const gui = new GUI({ width: 200 });
        // Mobile: keep main GUI collapsed/hidden by default and add a small toggle button
        if (isMobile) {
          try { gui.close(); } catch (e) {}
          if (gui.domElement) gui.domElement.style.display = 'none';
          const menuToggleBtn = document.createElement('button');
          menuToggleBtn.id = 'menuToggleBtn';
          menuToggleBtn.type = 'button';
          menuToggleBtn.title = 'Menu';
          menuToggleBtn.textContent = '≡';
          Object.assign(menuToggleBtn.style, {
            position: 'fixed',
            right: '64px',
            top: '12px',
            zIndex: 2147483647,
            width: '44px',
            height: '44px',
            borderRadius: '8px',
            border: '1px solid rgba(255,255,255,0.12)',
            background: 'rgba(0,0,0,0.4)',
            color: '#fff',
            fontSize: '20px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            cursor: 'pointer',
            backdropFilter: 'blur(4px)'
          });
          document.body.appendChild(menuToggleBtn);
          menuToggleBtn.addEventListener('click', () => {
            const el = gui.domElement;
            if (!el) return;
            if (el.style.display === 'none') {
              el.style.display = '';
              try { gui.open(); } catch (e) {}
              menuToggleBtn.textContent = '✕';
            } else {
              el.style.display = 'none';
              try { gui.close(); } catch (e) {}
              menuToggleBtn.textContent = '≡';
            }
          });
        }
        gui.add({ debug: false }, 'debug').onChange(function (value) {
          helper.visible = value;
        });

        // View distance and fog controls
        const initialFogColor = new THREE.Color(0x88ccee);
        const settings = {
          viewDistance: camera.far,
          // Fog is disabled by default and not adjustable
          fogEnabled: false,
          fogColor: '#' + initialFogColor.getHexString(),
          fogNear: 0,
          fogFar: 50
        };

        function applyViewDistance() {
          settings.viewDistance = Math.max(settings.viewDistance, camera.near + 0.1);
          camera.far = settings.viewDistance;
          camera.updateProjectionMatrix();
          if (scene.fog && settings.fogFar > camera.far) {
            settings.fogFar = camera.far;
            applyFog();
          }
        }

        function applyFog() {
          // Fog is disabled by default in this build; keep scene.fog null.
          scene.fog = null;
        }

        const viewFolder = gui.addFolder('View');
        viewFolder.add(settings, 'viewDistance', 10, 2000, 1).name('View Distance').onChange(applyViewDistance);

        // Fog GUI removed; fog remains disabled by default

    // Lights GUI removed - all light controls are fixed/disabled by default

        // Environment lighting (IBL) controls
        // Light settings object (used by the separate Light Settings GUI)
        const lightSettings = {
          // Hemisphere
          hemiIntensity: fillLight1.intensity,
          hemiSkyColor: '#' + fillLight1.color.getHexString(),
          hemiGroundColor: '#' + (fillLight1.groundColor ? fillLight1.groundColor.getHexString() : 'ffffff'),
          hemiX: fillLight1.position.x,
          hemiY: fillLight1.position.y,
          hemiZ: fillLight1.position.z,
          // Ambient
          ambIntensity: ambientLight.intensity,
          // Environment (IBL)
          envEnabled: true,
          envIntensity: 1.0
        };

        // Environment lighting (IBL) - controlled by lightSettings
        function applyEnv() {
          scene.environment = (lightSettings.envEnabled && roomEnvMap) ? roomEnvMap : null;
          // Update envMapIntensity on materials that support it
          scene.traverse((child) => {
            if (child.isMesh && child.material) {
              const mats = Array.isArray(child.material) ? child.material : [child.material];
              mats.forEach((m) => {
                if ('envMapIntensity' in m) {
                  m.envMapIntensity = (lightSettings.envEnabled && roomEnvMap) ? lightSettings.envIntensity : 0;
                  m.needsUpdate = true;
                }
              });
            }
          });
        }

        // Renderer exposure (overall brightness)
        const renderFolder = gui.addFolder('Render');
        const renderSettings = { exposure: renderer.toneMappingExposure ?? 1.0 };
        renderFolder.add(renderSettings, 'exposure', 0.1, 2.5, 0.01).name('Exposure').onChange((v) => {
          renderer.toneMappingExposure = v;
        });

        // Separate Light Settings GUI (kept apart from main settings)
        const lightGui = new GUI({ title: 'Light Settings', width: 320 });
        const hemiFolder = lightGui.addFolder('Hemisphere');
        hemiFolder.add(lightSettings, 'hemiIntensity', 0, 10, 0.01).name('Intensity').onChange((v) => {
          fillLight1.intensity = v;
        });
        hemiFolder.addColor(lightSettings, 'hemiSkyColor').name('Sky Color').onChange((v) => {
          fillLight1.color.set(v);
        });
        hemiFolder.addColor(lightSettings, 'hemiGroundColor').name('Ground Color').onChange((v) => {
          fillLight1.groundColor.set(v);
        });
        hemiFolder.add(lightSettings, 'hemiX', -50, 50, 0.1).name('Pos X').onChange((v) => {
          fillLight1.position.x = v;
        });
        hemiFolder.add(lightSettings, 'hemiY', -50, 50, 0.1).name('Pos Y').onChange((v) => {
          fillLight1.position.y = v;
        });
        hemiFolder.add(lightSettings, 'hemiZ', -50, 50, 0.1).name('Pos Z').onChange((v) => {
          fillLight1.position.z = v;
        });

        const ambFolder = lightGui.addFolder('Ambient');
        ambFolder.add(lightSettings, 'ambIntensity', 0, 2, 0.01).name('Intensity').onChange((v) => {
          ambientLight.intensity = v;
        });

        const envFolder2 = lightGui.addFolder('Environment');
        envFolder2.add(lightSettings, 'envEnabled').name('Enabled').onChange(applyEnv);
        envFolder2.add(lightSettings, 'envIntensity', 0, 3, 0.01).name('Intensity').onChange(applyEnv);

        // Mobile: keep Light Settings collapsed/hidden by default and add a small toggle button
        if (isMobile) {
          try { lightGui.close(); } catch (e) {}
          // hide the light GUI panel
          if (lightGui.domElement) lightGui.domElement.style.display = 'none';

          const lightToggleBtn = document.createElement('button');
          lightToggleBtn.id = 'lightToggleBtn';
          lightToggleBtn.type = 'button';
          lightToggleBtn.title = 'Light Settings';
          lightToggleBtn.textContent = '☼';
          Object.assign(lightToggleBtn.style, {
            position: 'fixed',
            right: '12px',
            top: '12px',
            zIndex: 2147483647,
            width: '44px',
            height: '44px',
            borderRadius: '8px',
            border: '1px solid rgba(255,255,255,0.12)',
            background: 'rgba(0,0,0,0.4)',
            color: '#fff',
            fontSize: '20px',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center',
            cursor: 'pointer',
            backdropFilter: 'blur(4px)'
          });
          document.body.appendChild(lightToggleBtn);

          lightToggleBtn.addEventListener('click', () => {
            const el = lightGui.domElement;
            if (!el) return;
            if (el.style.display === 'none') {
              el.style.display = '';
              try { lightGui.open(); } catch (e) {}
              lightToggleBtn.textContent = '✕';
            } else {
              el.style.display = 'none';
              try { lightGui.close(); } catch (e) {}
              lightToggleBtn.textContent = '☼';
            }
          });
        }

        // Initialize to current settings
        applyViewDistance();
        applyFog();
        applyEnv();
      }, onProgress, onError);

      

      function teleportPlayerIfOob() {
        if (camera.position.y <= -25) {
          playerCollider.start.set(0, 0.35, 0);
          playerCollider.end.set(0, 1, 0);
          playerCollider.radius = 0.35;
          camera.position.copy(playerCollider.end);
          camera.rotation.set(0, 0, 0);
        }
      }

      function animate() {
        // Use a single clock.getDelta() call so we can compute FPS correctly
        const frameDelta = Math.min(0.05, clock.getDelta()); // seconds (capped to avoid huge jumps)
        const deltaTime = frameDelta / STEPS_PER_FRAME;
        for (let i = 0; i < STEPS_PER_FRAME; i++) {
          controls(deltaTime);
          updatePlayer(deltaTime);
          teleportPlayerIfOob();
        }
        renderer.render(scene, camera);
        stats.update();

        // Update our FPS display: instantaneous and running average
  const instantFps = frameDelta > 0 ? (1 / frameDelta) : 0;
  fpsSamples.push(instantFps);
  if (fpsSamples.length > FPS_SAMPLE_MAX) fpsSamples.shift();
  const avgFps = fpsSamples.reduce((a, b) => a + b, 0) / fpsSamples.length;
  // Update spans: average first (prominent), instant smaller
  avgSpan.textContent = `AVG: ${avgFps.toFixed(1)} FPS`;
  instSpan.textContent = `INST: ${instantFps.toFixed(1)}`;
      }
    </script>
  </body>
</html>
